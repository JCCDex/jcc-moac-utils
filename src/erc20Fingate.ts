import BigNumber from "bignumber.js";
import chain3 = require("chain3");
import erc20ABI from "./abi/erc20ABI";
import MoacFingate from "./moacFingate";
import { isValidAmount, isValidHash, isValidJingtumAddress, isValidMoacAddress, isValidMoacSecret, validate } from "./validator";

/**
 * toolkit of erc20 fingate
 *
 * @class Erc20Fingate
 * @extends {MoacFingate}
 */
class Erc20Fingate extends MoacFingate {

    /**
     * instance of erc20 contract
     *
     * @private
     * @type {chain3.mc.contract}
     * @memberof Erc20Fingate
     */
    private _erc20ContractInstance: chain3.mc.contract;

    /**
     * contract address of erc20 token
     *
     * @private
     * @type {string}
     * @memberof Erc20Fingate
     */
    private _erc20ContractAddress: string;

    /**
     * Creates an instance of Erc20Fingate
     * @param {string} node moac node
     * @param {boolean} mainnet main net or test net
     * @memberof Erc20Fingate
     */
    constructor(node: string, mainnet: boolean) {
        /* istanbul ignore next  */

        super(node, mainnet);
        this._erc20ContractInstance = null;
        this._erc20ContractAddress = null;
    }

    /**
     * init instance of erc20 contract
     *
     * @param {string} moacFingateAddress contract address of moac fingate
     * @param {string} tokenContractAddress contract address of erc20 token
     * @memberof Erc20Fingate
     */
    @validate
    public initErc20Contract(@isValidMoacAddress moacFingateAddress: string, @isValidMoacAddress tokenContractAddress: string) {
        try {
            super.initMoacContract(moacFingateAddress);
            if (!super.contractInitialied(this._erc20ContractInstance, tokenContractAddress)) {
                this._erc20ContractAddress = tokenContractAddress;
                this._erc20ContractInstance = this.contract(erc20ABI).at(this._erc20ContractAddress);
            }
        } catch (e) {
            throw e;
        }
    }

    /**
     * destroy instance of erc20 contract
     *
     * @memberof Erc20Fingate
     */
    public close() {
        super.close();
        this._erc20ContractInstance = null;
    }

    /**
     * request balance of erc20 token
     *
     * @param {string} address moac address
     * @returns {Promise<string>} resolve 0 if request failed
     * @memberof Erc20Fingate
     */
    public async balanceOf(address: string): Promise<string> {
        let balance: string;
        try {
            const bnBalance = await this._erc20ContractInstance.balanceOf(address);
            balance = bnBalance.dividedBy(10 ** this._erc20ContractInstance.decimals()).toString(10);
        } catch (error) {
            balance = "0";
        }
        return balance;
    }

    /**
     * transfer erc20 token
     *
     * @param {number} amount amount of deposit
     * @param {string} moacSecret moac secret
     * @returns {Promise<string>} resolve hash if successful
     * @memberof Erc20Fingate
     */
    @validate
    public transfer(@isValidAmount amount: number, @isValidMoacSecret moacSecret: string): Promise<string> {
        return new Promise(async (resolve, reject) => {
            try {
                const moacAddress = MoacFingate.getAddress(moacSecret);
                const gasLimit = this.gasLimit;
                const gasPrice = await this.getGasPrice(this.minGasPrice);
                const nonce = await this.getNonce(moacAddress);
                const value = new BigNumber(amount).multipliedBy(10 ** this._erc20ContractInstance.decimals());
                const calldata = this._erc20ContractInstance.transfer.getData(this.moacContractInstance.address, value.toString(10));
                const tx = this.getTx(moacAddress, this._erc20ContractInstance.address, nonce, gasLimit, gasPrice, "0", calldata);
                const signedTransaction = this._chain3.signTransaction(tx, moacSecret);
                const hash = await this.sendRawSignedTransaction(signedTransaction);
                return resolve(hash);
            } catch (error) {
                return reject(error);
            }
        });
    }

    /**
     * deposit erc20 token
     *
     * @param {string} jtAddress jingtum address
     * @param {number} amount amount of deposit
     * @param {string} hash generated by `transfer` api of ERC20Fingate
     * @param {string} moacSecret moac secret
     * @returns {Promise<string>} reslove hash of transaction if successful
     * @memberof MoacFingate
     */
    @validate
    public depositToken(@isValidJingtumAddress jtAddress: string, @isValidAmount amount: number, @isValidHash hash: string, @isValidMoacSecret moacSecret: string): Promise<string> {
        return new Promise(async (resolve, reject) => {
            try {
                const moacAddress = MoacFingate.getAddress(moacSecret);
                const value = new BigNumber(amount).multipliedBy(10 ** this.moacDecimals);
                const gasLimit = this.gasLimit;
                const gasPrice = await this.getGasPrice(this.minGasPrice);
                const nonce = await this.getNonce(moacAddress);
                const calldata = this.moacContractInstance.depositToken.getData(jtAddress, this._erc20ContractAddress, value.toString(10), hash);
                const tx = this.getTx(moacAddress, this.moacContractInstance.address, nonce, gasLimit, gasPrice, "0", calldata);
                const signedTransaction = this._chain3.signTransaction(tx, moacSecret);
                const txHash = await this.sendRawSignedTransaction(signedTransaction);
                return resolve(txHash);
            } catch (error) {
                return reject(error);
            }
        });
    }
}

export default Erc20Fingate;
