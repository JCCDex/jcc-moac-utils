"use strict";

import BigNumber from "bignumber.js";
import fingateABI from "./abi/fingateABI";
import Moac from "./moac";
import { ITransactionOption } from "./model/transaction";
import SmartContract from "./smartContract";
import { isValidAmount, isValidHash, isValidJingtumAddress, isValidMoacAddress, isValidMoacSecret, validate } from "./validator";

/**
 * toolkit of moac fingate
 *
 * @class Fingate
 */
class Fingate extends SmartContract {

    /**
     * Creates an instance of Fingate
     * @memberof Fingate
     */
    constructor() {
        super();
    }

    /**
     * init instance of moac contract
     *
     * @param {string} fingateAddress contract address of moac fingate
     * @param {Moac} moac instance
     * @memberof Fingate
     */
    @validate
    public init(@isValidMoacAddress fingateAddress: string, moac: Moac) {
        try {
            super.init(fingateAddress, moac, fingateABI);
        } catch (e) {
            throw e;
        }
    }

    /**
     * close chain3 & destroy instance of contract
     *
     * @memberof Fingate
     */
    public destroy() {
        super.destroy();
    }

    /**
     * request deposit state
     *
     * @param {string} address moac address
     * @param {string} [contractAddress="0x0000000000000000000000000000000000000000"] contract address of token
     * @returns {(Promise<Array<BigNumber | string>>)}
     * @memberof Fingate
     */
    @validate
    public depositState(@isValidMoacAddress address: string, @isValidMoacAddress contractAddress = "0x0000000000000000000000000000000000000000"): Promise<Array<BigNumber | string>> {
        return new Promise(async (resolve, reject) => {
            try {
                address = Moac.prefix0x(address);
                const state = await super.callABI("depositState", contractAddress, address);
                return resolve(state);
            } catch (error) {
                return reject(error);
            }
        });
    }

    /**
     * validate deposit state is pending or not
     *
     * @param {(Array<BigNumber | string>)} state
     * @returns {boolean} return true if the state is pending
     * @memberof Fingate
     */
    public isPending(state: Array<BigNumber | string>): boolean {
        return state[0].toString(10) !== "0" || state[1] !== "";
    }

    /**
     * deposit moac
     *
     * @param {string} jtAddress jingtum address
     * @param {string} amount amount of deposit
     * @param {string} moacSecret moac secret
     * @param {ITransactionOption} options specify gasPrice, nonce, gasLimit etc.
     * @returns {Promise<string>} resolve hash if successful
     * @memberof Fingate
     */
    @validate
    public deposit(@isValidJingtumAddress jtAddress: string, @isValidAmount amount: string, @isValidMoacSecret moacSecret: string, options?: ITransactionOption): Promise<string> {
        return new Promise(async (resolve, reject) => {
            try {
                const moacAddress = Moac.getAddress(moacSecret);
                const value = new BigNumber(amount).toString(10);
                options = await this.moac.getOptions(options || {}, moacAddress);
                const calldata = await super.callABI("deposit", jtAddress);
                const rawTx = this.moac.getTx(moacAddress, this.contract.address, options.nonce, options.gasLimit, options.gasPrice, value, calldata);
                const signedTransaction = this.moac.signTransaction(rawTx, moacSecret);
                const hash = await this.moac.sendRawSignedTransaction(signedTransaction);
                return resolve(hash);
            } catch (error) {
                return reject(error);
            }
        });
    }

    /**
     * deposit erc20 token
     *
     * @param {string} jtAddress jingtum address
     * @param {string} tokenAddress erc20 contract address
     * @param {number} decimals token decimals
     * @param {string} amount amount of deposit
     * @param {string} hash generated by `transfer` api of ERC20
     * @param {string} moacSecret moac secret
     * @param {ITransactionOption} options specify gasPrice, nonce, gasLimit etc.
     * @returns {Promise<string>} reslove hash of transaction if successful
     * @memberof Fingate
     */
    @validate
    public depositToken(@isValidJingtumAddress jtAddress: string, @isValidMoacAddress tokenAddress: string, decimals: number, @isValidAmount amount: string, @isValidHash hash: string, @isValidMoacSecret moacSecret: string, options?: ITransactionOption): Promise<string> {
        return new Promise(async (resolve, reject) => {
            try {
                const moacAddress = Moac.getAddress(moacSecret);
                const value = new BigNumber(amount).multipliedBy(10 ** decimals);
                options = await this.moac.getOptions(options || {}, moacAddress);
                const calldata = await super.callABI("depositToken", jtAddress, tokenAddress, value.toString(10), hash);
                const tx = this.moac.getTx(moacAddress, this.contract.address, options.nonce, options.gasLimit, options.gasPrice, "0", calldata);
                const signedTransaction = this.moac.signTransaction(tx, moacSecret);
                const txHash = await this.moac.sendRawSignedTransaction(signedTransaction);
                return resolve(txHash);
            } catch (error) {
                return reject(error);
            }
        });
    }
}

export default Fingate;
